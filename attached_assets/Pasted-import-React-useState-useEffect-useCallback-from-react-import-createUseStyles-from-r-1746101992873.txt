import React, { useState, useEffect, useCallback } from 'react';
import { createUseStyles } from 'react-jss';
import { FaBitcoin, FaServer, FaTools, FaBolt, FaTemperatureHigh, FaChartLine, FaArrowUp, FaLock, FaCheck } from 'react-icons/fa';

// JSS Styles
const useStyles = createUseStyles({
  '@global': {
    'body': {
      margin: 0,
      padding: 0,
      fontFamily: '"Roboto", "Segoe UI", Arial, sans-serif',
      backgroundColor: '#f0f4f8',
      color: '#333',
    }
  },
  app: {
    maxWidth: '1200px',
    margin: '0 auto',
    padding: '20px',
  },
  header: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: '30px',
    backgroundColor: '#1e2a38',
    color: '#fff',
    padding: '20px',
    borderRadius: '10px',
    boxShadow: '0 4px 20px rgba(0, 0, 0, 0.15)',
    '& h1': {
      margin: 0,
      fontSize: '28px',
      display: 'flex',
      alignItems: 'center',
      '& svg': {
        color: '#f7931a',
        marginRight: '10px',
      }
    }
  },
  statusPanel: {
    backgroundColor: '#fff',
    borderRadius: '10px',
    padding: '20px',
    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.08)',
    marginBottom: '20px',
  },
  stats: {
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
    gap: '15px',
    marginBottom: '20px',
  },
  statCard: {
    padding: '15px',
    backgroundColor: '#f8f9fa',
    borderRadius: '8px',
    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.06)',
    transition: 'transform 0.2s ease, box-shadow 0.2s ease',
    '&:hover': {
      transform: 'translateY(-3px)',
      boxShadow: '0 6px 12px rgba(0, 0, 0, 0.1)',
    }
  },
  statTitle: {
    margin: '0 0 10px 0',
    fontSize: '14px',
    color: '#6c757d',
    display: 'flex',
    alignItems: 'center',
    '& svg': {
      marginRight: '8px',
    }
  },
  statValue: {
    margin: 0,
    fontSize: '24px',
    fontWeight: 'bold',
    color: '#2c3e50',
  },
  miningRigSection: {
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',
    gap: '20px',
    marginBottom: '30px',
  },
  miningRig: {
    backgroundColor: '#fff',
    borderRadius: '10px',
    padding: '20px',
    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.08)',
    display: 'flex',
    flexDirection: 'column',
  },
  rigHeader: {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: '15px',
    '& h3': {
      margin: 0,
      fontSize: '18px',
      fontWeight: 'bold',
      color: '#2c3e50',
    }
  },
  rigStats: {
    display: 'grid',
    gridTemplateColumns: '1fr 1fr',
    gap: '10px',
    margin: '15px 0',
  },
  rigStat: {
    fontSize: '14px',
    color: '#6c757d',
  },
  rigStatValue: {
    fontWeight: 'bold',
    color: '#2c3e50',
  },
  button: {
    backgroundColor: '#f7931a',
    color: '#fff',
    border: 'none',
    borderRadius: '5px',
    padding: '10px 15px',
    cursor: 'pointer',
    fontSize: '14px',
    fontWeight: 'bold',
    transition: 'background-color 0.2s ease',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    '&:hover': {
      backgroundColor: '#e67e0e',
    },
    '&:disabled': {
      backgroundColor: '#ccc',
      cursor: 'not-allowed',
    },
    '& svg': {
      marginRight: '8px',
    }
  },
  upgradeButton: {
    backgroundColor: '#3498db',
    '&:hover': {
      backgroundColor: '#2980b9',
    }
  },
  buttonSmall: {
    fontSize: '12px',
    padding: '8px 12px',
  },
  progressBar: {
    width: '100%',
    height: '10px',
    backgroundColor: '#e9ecef',
    borderRadius: '5px',
    marginTop: '10px',
    overflow: 'hidden',
  },
  progressFill: {
    height: '100%',
    backgroundColor: '#4BB543',
    borderRadius: '5px',
    transition: 'width 0.1s ease-in-out',
  },
  marketSection: {
    backgroundColor: '#fff',
    borderRadius: '10px',
    padding: '20px',
    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.08)',
    marginBottom: '30px',
  },
  marketHeader: {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: '15px',
    '& h3': {
      margin: 0,
      fontSize: '18px',
      fontWeight: 'bold',
      color: '#2c3e50',
    }
  },
  priceChart: {
    height: '200px',
    position: 'relative',
    marginTop: '20px',
  },
  pricePoint: {
    position: 'absolute',
    width: '3px',
    backgroundColor: '#f7931a',
    bottom: 0,
    transition: 'height 0.3s ease',
  },
  tooltip: {
    position: 'absolute',
    backgroundColor: '#333',
    color: '#fff',
    padding: '5px 10px',
    borderRadius: '5px',
    fontSize: '12px',
    zIndex: 10,
    pointerEvents: 'none',
    whiteSpace: 'nowrap',
  },
  hashingPanel: {
    position: 'relative',
    height: '300px',
    backgroundColor: '#fff',
    borderRadius: '10px',
    padding: '20px',
    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.08)',
    marginBottom: '30px',
    overflow: 'hidden',
  },
  codeBlock: {
    fontFamily: 'monospace',
    fontSize: '12px',
    backgroundColor: '#2c3e50',
    color: '#ecf0f1',
    padding: '15px',
    borderRadius: '8px',
    height: '220px',
    overflow: 'auto',
    whiteSpace: 'pre-wrap',
  },
  actions: {
    display: 'flex',
    gap: '10px',
    marginTop: '15px',
  },
  blockMined: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center',
    alignItems: 'center',
    color: '#fff',
    zIndex: 10,
    padding: '20px',
    textAlign: 'center',
    '& h3': {
      margin: '0 0 10px 0',
      fontSize: '24px',
    },
    '& p': {
      margin: '10px 0',
      fontSize: '16px',
    },
    '& svg': {
      fontSize: '48px',
      color: '#f7931a',
      marginBottom: '15px',
    }
  },
  nonce: {
    color: '#2ecc71',
    fontWeight: 'bold',
  },
  difficulty: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginTop: '15px',
    padding: '10px',
    backgroundColor: '#f8f9fa',
    borderRadius: '5px',
    '& .label': {
      fontWeight: 'bold',
    }
  },
  difficultyLevel: {
    display: 'flex',
    gap: '5px',
  },
  difficultyDot: {
    width: '15px',
    height: '15px',
    borderRadius: '50%',
    backgroundColor: '#e9ecef',
  },
  activeDot: {
    backgroundColor: '#f7931a',
  },
  shopSection: {
    backgroundColor: '#fff',
    borderRadius: '10px',
    padding: '20px',
    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.08)',
  },
  shopGrid: {
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fill, minmax(250px, 1fr))',
    gap: '20px',
    marginTop: '20px',
  },
  shopItem: {
    backgroundColor: '#f8f9fa',
    borderRadius: '8px',
    padding: '15px',
    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.06)',
    display: 'flex',
    flexDirection: 'column',
  },
  shopItemHeader: {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: '10px',
    '& h4': {
      margin: 0,
      fontSize: '16px',
      fontWeight: 'bold',
      color: '#2c3e50',
    }
  },
  shopItemPrice: {
    display: 'flex',
    alignItems: 'center',
    fontSize: '14px',
    fontWeight: 'bold',
    color: '#f7931a',
    '& svg': {
      marginRight: '4px',
    }
  },
  shopItemDesc: {
    fontSize: '14px',
    color: '#6c757d',
    marginBottom: '15px',
    flexGrow: 1,
  },
  shopItemStats: {
    fontSize: '12px',
    marginBottom: '15px',
    '& p': {
      margin: '5px 0',
      display: 'flex',
      justifyContent: 'space-between',
    },
    '& .label': {
      color: '#6c757d',
    },
    '& .value': {
      fontWeight: 'bold',
      color: '#2c3e50',
    }
  },
  notification: {
    position: 'fixed',
    bottom: '20px',
    right: '20px',
    backgroundColor: '#4BB543',
    color: '#fff',
    padding: '15px',
    borderRadius: '5px',
    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',
    zIndex: 1000,
    maxWidth: '300px',
    animation: '$fadeIn 0.3s, $fadeOut 0.3s 3.7s',
  },
  '@keyframes fadeIn': {
    from: { opacity: 0, transform: 'translateY(20px)' },
    to: { opacity: 1, transform: 'translateY(0)' }
  },
  '@keyframes fadeOut': {
    from: { opacity: 1, transform: 'translateY(0)' },
    to: { opacity: 0, transform: 'translateY(20px)' }
  },
});

// Mining hardware templates
const hardwareTemplates = [
  {
    id: 'basic-gpu',
    name: 'Basic GPU Miner',
    hashrate: 30,
    power: 150,
    price: 0.5,
    description: 'Entry-level gaming GPU repurposed for mining.',
    thermals: 70,
  },
  {
    id: 'mid-gpu',
    name: 'Mid-Range GPU',
    hashrate: 60,
    power: 180,
    price: 1.2,
    description: 'Decent performance GPU with good efficiency.',
    thermals: 75,
  },
  {
    id: 'high-gpu',
    name: 'High-End GPU',
    hashrate: 100,
    power: 250,
    price: 2.5,
    description: 'Premium GPU with excellent mining capabilities.',
    thermals: 80,
  },
  {
    id: 'asic-basic',
    name: 'Basic ASIC Miner',
    hashrate: 250,
    power: 1200,
    price: 5,
    description: 'Entry-level ASIC miner designed specifically for Bitcoin.',
    thermals: 85,
  },
  {
    id: 'asic-pro',
    name: 'Professional ASIC',
    hashrate: 500,
    power: 1800,
    price: 10,
    description: 'High performance ASIC with excellent efficiency.',
    thermals: 90,
  },
  {
    id: 'asic-industrial',
    name: 'Industrial ASIC',
    hashrate: 1000,
    power: 3000,
    price: 20,
    description: 'Enterprise-grade ASIC miner for serious operations.',
    thermals: 95,
  },
];

// Upgrades for miners
const upgradeTemplates = [
  {
    id: 'cooling-basic',
    name: 'Basic Cooling System',
    price: 0.3,
    effects: { thermals: -10 },
    description: 'Improve airflow and reduce operating temperatures.',
  },
  {
    id: 'power-optimizer',
    name: 'Power Optimizer',
    price: 0.5,
    effects: { power: -15 },
    description: 'Reduce power consumption with intelligent voltage regulation.',
  },
  {
    id: 'overclock-kit',
    name: 'Overclocking Kit',
    price: 0.8,
    effects: { hashrate: 20, thermals: 15 },
    description: 'Increase hashrate at the cost of higher temperatures.',
  },
  {
    id: 'efficiency-module',
    name: 'Efficiency Module',
    price: 1.5,
    effects: { hashrate: 10, power: -10 },
    description: 'Balanced improvement to both hashrate and power consumption.',
  },
];

// Function to generate a pseudo block header
const generateBlockHeader = (previousHash, merkleRoot, timestamp, difficulty) => {
  return {
    version: "0x20000000",
    previousHash,
    merkleRoot,
    timestamp,
    bits: difficulty.toString(16).padStart(8, '0'),
    nonce: 0
  };
};

// Format large numbers with K, M, G, T suffixes
const formatNumber = (num) => {
  if (num >= 1000000000000) {
    return (num / 1000000000000).toFixed(2) + 'T';
  }
  if (num >= 1000000000) {
    return (num / 1000000000).toFixed(2) + 'G';
  }
  if (num >= 1000000) {
    return (num / 1000000).toFixed(2) + 'M';
  }
  if (num >= 1000) {
    return (num / 1000).toFixed(2) + 'K';
  }
  return num.toFixed(2);
};

// Bitcoin simulator component
const BitcoinMiningSimulator = () => {
  const classes = useStyles();
  
  // State declarations
  const [bitcoin, setBitcoin] = useState(0);
  const [bitcoinPrice, setBitcoinPrice] = useState(45000);
  const [priceHistory, setPriceHistory] = useState([45000]);
  const [priceChangeDirection, setPriceChangeDirection] = useState(1);
  const [totalHashRate, setTotalHashRate] = useState(0);
  const [powerUsage, setPowerUsage] = useState(0);
  const [electricityCost, setElectricityCost] = useState(0.12); // $ per kWh
  const [miners, setMiners] = useState([]);
  const [dayCount, setDayCount] = useState(1);
  const [running, setRunning] = useState(false);
  const [selectedTab, setSelectedTab] = useState('mine');
  const [mining, setMining] = useState(false);
  const [miningProgress, setMiningProgress] = useState(0);
  const [currentNonce, setCurrentNonce] = useState(0);
  const [blockFound, setBlockFound] = useState(false);
  const [blockReward, setBlockReward] = useState(6.25);
  const [networkDifficulty, setNetworkDifficulty] = useState(1);
  const [notification, setNotification] = useState(null);
  
  // Blockchain simulation state
  const [blockHeader, setBlockHeader] = useState(null);
  const [blocksMined, setBlocksMined] = useState(0);
  
  // Initialize block header when component mounts
  useEffect(() => {
    const initialHeader = generateBlockHeader(
      "0000000000000000000a23aeac5a4ac2cd0de95e82ae908e5eda4d97d88cc15e",
      "38a1bff54c3e4fe4802a926a0010cd84edbcae8687f85b7e44cd5b04b4292fd3",
      Math.floor(Date.now() / 1000),
      networkDifficulty
    );
    setBlockHeader(initialHeader);
  }, []);
  
  // Main game loop
  useEffect(() => {
    if (!running) return;
    
    const gameInterval = setInterval(() => {
      // Update day counter
      setDayCount(prev => prev + 1);
      
      // Update Bitcoin price with some randomness
      const random = Math.random();
      if (random > 0.95) {
        // Larger price change occasionally (5% chance)
        setPriceChangeDirection(Math.random() > 0.5 ? 1 : -1);
      } else if (random > 0.7) {
        // Smaller direction change (25% chance)
        setPriceChangeDirection(prev => Math.random() > 0.5 ? prev : -prev);
      }
      
      const changePercent = (Math.random() * 2) * priceChangeDirection;
      const newPrice = Math.max(1000, bitcoinPrice * (1 + changePercent / 100));
      setBitcoinPrice(newPrice);
      setPriceHistory(prev => [...prev.slice(-30), newPrice]);
      
      // Calculate passive income from miners
      const dailyBtcEarnings = (totalHashRate / 1000000) * 0.0001 * Math.pow(0.8, networkDifficulty - 1);
      setBitcoin(prev => prev + dailyBtcEarnings);
      
      // Calculate electricity costs
      const dailyPowerCost = (powerUsage / 1000) * 24 * electricityCost / 30; // Cost per day
      setBitcoin(prev => Math.max(0, prev - dailyPowerCost / bitcoinPrice));
      
      // Update difficulty occasionally
      if (dayCount % 14 === 0 && networkDifficulty < 5) {
        setNetworkDifficulty(prev => prev + 1);
        showNotification("Network difficulty increased!");
        
        // Generate new block header when difficulty changes
        const newHeader = generateBlockHeader(
          Math.random().toString(16).substring(2, 66),
          Math.random().toString(16).substring(2, 66),
          Math.floor(Date.now() / 1000),
          networkDifficulty + 1
        );
        setBlockHeader(newHeader);
      }
      
      // Occasional hardware failure or temperature issue
      if (miners.length > 0 && Math.random() > 0.97) {
        const randomMinerIndex = Math.floor(Math.random() * miners.length);
        if (miners[randomMinerIndex].thermals > 85) {
          showNotification(`Warning: ${miners[randomMinerIndex].name} is overheating!`);
          // Could implement actual penalties here
        }
      }
      
      // Adjust block reward over time (halving)
      if (dayCount % 210 === 0) {
        setBlockReward(prev => prev / 2);
        showNotification("Bitcoin halving event occurred! Block reward reduced.");
      }
      
    }, 2000); // 2 seconds = 1 day in simulation
    
    return () => clearInterval(gameInterval);
  }, [running, bitcoinPrice, priceChangeDirection, totalHashRate, powerUsage, electricityCost, networkDifficulty, dayCount, miners]);
  
  // Simulation of mining process
  useEffect(() => {
    if (!mining || !blockHeader) return;
    
    let nonceCounter = currentNonce;
    let progress = 0;
    const difficultyFactor = Math.pow(16, networkDifficulty);
    const hashPower = totalHashRate;
    
    const miningInterval = setInterval(() => {
      // Simulate hash attempts
      const hashesPerTick = hashPower / 10;
      nonceCounter += hashesPerTick;
      
      // Update nonce display every few ticks (for UI)
      if (Math.random() > 0.7) {
        setCurrentNonce(Math.floor(nonceCounter));
      }
      
      // Calculate chance of finding a block based on hashrate and difficulty
      const blockChance = hashPower / difficultyFactor / 1000000;
      progress += blockChance * 100;
      
      // If we're simulating a success
      if (progress >= 100 || Math.random() < blockChance * 5) {
        clearInterval(miningInterval);
        setMiningProgress(100);
        setBlockFound(true);
        setBlocksMined(prev => prev + 1);
        setBitcoin(prev => prev + blockReward);
        showNotification(`Success! You mined a block and earned ${blockReward} BTC!`);
        
        // Generate new block for next mining session
        setTimeout(() => {
          const newHeader = generateBlockHeader(
            Math.random().toString(16).substring(2, 66),
            Math.random().toString(16).substring(2, 66),
            Math.floor(Date.now() / 1000),
            networkDifficulty
          );
          setBlockHeader(newHeader);
          setBlockFound(false);
          setMining(false);
          setMiningProgress(0);
          setCurrentNonce(0);
        }, 3000);
      } else {
        setMiningProgress(progress);
      }
    }, 200);
    
    return () => clearInterval(miningInterval);
  }, [mining, blockHeader, totalHashRate, networkDifficulty, currentNonce, blockReward]);
  
  // Function to add a new mining rig
  const addMiner = (hardwareTemplate) => {
    if (bitcoin < hardwareTemplate.price) {
      showNotification("Not enough Bitcoin to purchase this hardware!");
      return;
    }
    
    setBitcoin(prev => prev - hardwareTemplate.price);
    
    const newMiner = {
      id: Date.now(),
      ...hardwareTemplate,
      upgrades: [],
      efficiency: 1.0,
      status: 'active'
    };
    
    setMiners(prev => [...prev, newMiner]);
    updateMiningStats([...miners, newMiner]);
    showNotification(`Purchased new ${hardwareTemplate.name}!`);
  };
  
  // Function to add upgrade to a miner
  const addUpgrade = (minerId, upgrade) => {
    if (bitcoin < upgrade.price) {
      showNotification("Not enough Bitcoin to purchase this upgrade!");
      return;
    }
    
    setBitcoin(prev => prev - upgrade.price);
    
    const updatedMiners = miners.map(miner => {
      if (miner.id === minerId) {
        // Apply upgrade effects
        const updatedMiner = { ...miner };
        updatedMiner.upgrades = [...miner.upgrades, upgrade.id];
        
        if (upgrade.effects.hashrate) {
          updatedMiner.hashrate += upgrade.effects.hashrate;
        }
        if (upgrade.effects.power) {
          updatedMiner.power += upgrade.effects.power;
        }
        if (upgrade.effects.thermals) {
          updatedMiner.thermals += upgrade.effects.thermals;
        }
        
        return updatedMiner;
      }
      return miner;
    });
    
    setMiners(updatedMiners);
    updateMiningStats(updatedMiners);
    showNotification(`Upgrade installed on your mining hardware!`);
  };
  
  // Update total hashrate and power usage when miners change
  const updateMiningStats = (currentMiners) => {
    let totalHash = 0;
    let totalPower = 0;
    
    currentMiners.forEach(miner => {
      if (miner.status === 'active') {
        totalHash += miner.hashrate;
        totalPower += miner.power;
      }
    });
    
    setTotalHashRate(totalHash);
    setPowerUsage(totalPower);
  };
  
  // Toggle miner status (on/off)
  const toggleMinerStatus = (minerId) => {
    const updatedMiners = miners.map(miner => {
      if (miner.id === minerId) {
        return {
          ...miner,
          status: miner.status === 'active' ? 'inactive' : 'active'
        };
      }
      return miner;
    });
    
    setMiners(updatedMiners);
    updateMiningStats(updatedMiners);
  };
  
  // Toggle mining process
  const toggleMining = () => {
    if (totalHashRate <= 0) {
      showNotification("You need mining hardware to start mining!");
      return;
    }
    setMining(!mining);
  };
  
  // Handle notifications
  const showNotification = (message) => {
    setNotification(message);
    setTimeout(() => setNotification(null), 4000);
  };
  
  // Format a date string from day count
  const getDateString = () => {
    const startDate = new Date(2021, 0, 1);
    const currentDate = new Date(startDate);
    currentDate.setDate(startDate.getDate() + dayCount);
    return currentDate.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
  };
  
  // Calculate daily profit
  const calculateDailyProfit = () => {
    const dailyBtcEarnings = (totalHashRate / 1000000) * 0.0001 * Math.pow(0.8, networkDifficulty - 1);
    const dailyPowerCost = (powerUsage / 1000) * 24 * electricityCost / 30; // Cost per day in USD
    const dailyPowerCostBtc = dailyPowerCost / bitcoinPrice;
    
    return dailyBtcEarnings - dailyPowerCostBtc;
  };
  
  // Calculate ROI days for a hardware purchase
  const calculateROI = (price) => {
    const dailyProfit = calculateDailyProfit();
    if (dailyProfit <= 0) return "∞";
    
    const daysToROI = price / dailyProfit;
    return daysToROI > 1000 ? "∞" : Math.ceil(daysToROI);
  };
  
  // Format block header for display
  const formatBlockHeader = (header) => {
    if (!header) return "";
    return (
      `Version: ${header.version}\n` +
      `Previous Block Hash: ${header.previousHash}\n` +
      `Merkle Root: ${header.merkleRoot}\n` +
      `Timestamp: ${header.timestamp}\n` +
      `Difficulty Target: ${header.bits}\n` +
      `Nonce: ${currentNonce}`
    );
  };

  return (
    <div className={classes.app}>
      <div className={classes.header}>
        <h1><FaBitcoin size={24} /> Bitcoin Mining Simulator</h1>
        <div>
          {running ? (
            <button className={classes.button} onClick={() => setRunning(false)}>
              Pause Simulation
            </button>
          ) : (
            <button className={classes.button} onClick={() => setRunning(true)}>
              Start Simulation
            </button>
          )}
        </div>
      </div>
      
      <div className={classes.statusPanel}>
        <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '15px' }}>
          <h2 style={{ margin: 0 }}>Simulation Day: {dayCount} ({getDateString()})</h2>
          <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
            <button 
              className={`${classes.button} ${classes.buttonSmall}`} 
              style={{ backgroundColor: selectedTab === 'mine' ? '#1e2a38' : '#6c757d' }}
              onClick={() => setSelectedTab('mine')}
            >
              Mining Operation
            </button>
            <button 
              className={`${classes.button} ${classes.buttonSmall}`} 
              style={{ backgroundColor: selectedTab === 'shop' ? '#1e2a38' : '#6c757d' }}
              onClick={() => setSelectedTab('shop')}
            >
              Hardware Shop
            </button>
          </div>
        </div>
        
        <div className={classes.stats}>
          <div className={classes.statCard}>
            <h3 className={classes.statTitle}><FaBitcoin /> Bitcoin Balance</h3>
            <p className={classes.statValue}>{bitcoin.toFixed(8)} BTC</p>
            <p style={{ margin: '5px 0 0 0', color: '#6c757d', fontSize: '14px' }}>
              (${(bitcoin * bitcoinPrice).toFixed(2)})
            </p>
          </div>
          
          <div className={classes.statCard}>
            <h3 className={classes.statTitle}><FaChartLine /> BTC Price</h3>
            <p className={classes.statValue}>${bitcoinPrice.toFixed(2)}</p>
            <p style={{ 
              margin: '5px 0 0 0', 
              color: priceChangeDirection > 0 ? '#28a745' : '#dc3545', 
              fontSize: '14px',
              display: 'flex',
              alignItems: 'center' 
            }}>
              {priceChangeDirection > 0 ? <FaArrowUp style={{marginRight: '3px'}} /> : '↓'}
              {Math.abs(((priceHistory[priceHistory.length-1] / priceHistory[Math.max(0, priceHistory.length-2)]) - 1) * 100).toFixed(2)}%
            </p>
          </div>
          
          <div className={classes.statCard}>
            <h3 className={classes.statTitle}><FaServer /> Total Hashrate</h3>
            <p className={classes.statValue}>{formatNumber(totalHashRate)} H/s</p>
          </div>
          
          <div className={classes.statCard}>
            <h3 className={classes.statTitle}><FaBolt /> Power Consumption</h3>
            <p className={classes.statValue}>{powerUsage} W</p>
            <p style={{ margin: '5px 0 0 0', color: '#6c757d', fontSize: '14px' }}>
              ${((powerUsage / 1000) * 24 * electricityCost).toFixed(2)}/day
            </p>
          </div>
          
          <div className={classes.statCard}>
            <h3 className={classes.statTitle}><FaLock /> Blocks Mined</h3>
            <p className={classes.statValue}>{blocksMined}</p>
          </div>
          
          <div className={classes.statCard}>
            <h3 className={classes.statTitle}><FaTemperatureHigh /> Network Difficulty</h3>
            <div className={classes.difficultyLevel}>
              {[1, 2, 3, 4, 5].map(level => (
                <div 
                  key={level} 
                  className={`${classes.difficultyDot} ${level <= networkDifficulty ? classes.activeDot : ''}`}
                />
              ))}
            </div>
            <p style={{ margin: '5px 0 0 0', color: '#6c757d', fontSize: '14px' }}>
              Block reward: {blockReward} BTC
            </p>
          </div>
        </div>
      </div>
      
      {selectedTab === 'mine' && (
        <>
          <div className={classes.hashingPanel}>
            <h3>Bitcoin Mining Simulation</h3>
            
            <div className={classes.codeBlock}>
              {formatBlockHeader(blockHeader)}
            </div>
            
            <div className={classes.difficulty}>
              <span className="label">Target: </span>
              <span>{'0'.repeat(networkDifficulty) + '1' + '0'.repeat(63 - networkDifficulty)}</span>
            </div>
            
            <div className={classes.actions}>
              <button 
                className={classes.button} 
                onClick={toggleMining}
                disabled={mining || totalHashRate <= 0 || blockFound}
              >
                {mining ? 'Mining...' : 'Start Mining'}
              </button>
              
              {mining && (
                <div style={{ flex: 1, marginLeft: '10px' }}>
                  <div className={classes.progressBar}>
                    <div 
                      className={classes.progressFill} 
                      style={{ width: `${miningProgress}%` }}
                    />
                  </div>
                  <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '12px', marginTop: '5px' }}>
                    <span>Nonce: <span className={classes.nonce}>{currentNonce.toLocaleString()}</span></span>
                    <span>Progress: {miningProgress.toFixed(2)}%</span>
                  </div>
                </div>
              )}
            </div>
            
            {blockFound && (
              <div className={classes.blockMined}>
                <FaCheck size={48} />
                <h3>Block Successfully Mined!</h3>
                <p>You found a valid hash solution and earned {blockReward} BTC</p>
                <p>Your total: {bitcoin.toFixed(8)} BTC</p>
              </div>
            )}
          </div>
          
          <div className={classes.marketSection}>
            <div className={classes.marketHeader}>
              <h3>Bitcoin Market Price</h3>
              <p>${bitcoinPrice.toFixed(2)}</p>
            </div>
            
            <div className={classes.priceChart}>
              {priceHistory.map((price, index) => {
                const maxPrice = Math.max(...priceHistory) * 1.1;
                const height = (price / maxPrice) * 100;
                const width = 100 / priceHistory.length;
                const left = width * index;
                
                return (
                  <div
                    key={index}
                    className={classes.pricePoint}
                    style={{
                      height: `${height}%`,
                      width: `${width}%`,
                      left: `${left}%`,
                      backgroundColor: priceHistory[index] > (priceHistory[index-1] || priceHistory[index]) ? '#28a745' : '#dc3545'
                    }}
                  />
                );
              })}
            </div>
            
            <div style={{ display: 'flex', justifyContent: 'space-between', marginTop: '10px' }}>
              <span>Day {Math.max(1, dayCount - priceHistory.length)}</span>
              <span>Day {dayCount}</span>
            </div>
          </div>
          
          <h3>Your Mining Operation</h3>
          
          <div className={classes.miningRigSection}>
            {miners.length === 0 ? (
              <div style={{ 
                padding: '30px', 
                textAlign: 'center', 
                backgroundColor: '#f8f9fa', 
                borderRadius: '10px',
                color: '#6c757d' 
              }}>
                <p>You don't have any mining hardware yet.</p>
                <p>Visit the Hardware Shop to get started!</p>
                <button 
                  className={classes.button} 
                  onClick={() => setSelectedTab('shop')}
                >
                  Go to Hardware Shop
                </button>
              </div>
            ) : (
              miners.map(miner => (
                <div key={miner.id} className={classes.miningRig}>
                  <div className={classes.rigHeader}>
                    <h3>{miner.name}</h3>
                    <div>
                      <button
                        className={`${classes.button} ${classes.buttonSmall}`}
                        style={{ 
                          backgroundColor: miner.status === 'active' ? '#28a745' : '#dc3545',
                        }}
                        onClick={() => toggleMinerStatus(miner.id)}
                      >
                        {miner.status === 'active' ? 'Running' : 'Stopped'}
                      </button>
                    </div>
                  </div>
                  
                  <div className={classes.rigStats}>
                    <div className={classes.rigStat}>
                      <span>Hashrate: </span>
                      <span className={classes.rigStatValue}>{formatNumber(miner.hashrate)} H/s</span>
                    </div>
                    <div className={classes.rigStat}>
                      <span>Power: </span>
                      <span className={classes.rigStatValue}>{miner.power}W</span>
                    </div>
                    <div className={classes.rigStat}>
                      <span>Efficiency: </span>
                      <span className={classes.rigStatValue}>{(miner.hashrate / miner.power).toFixed(2)} H/W</span>
                    </div>
                    <div className={classes.rigStat}>
                      <span>Temperature: </span>
                      <span 
                        className={classes.rigStatValue}
                        style={{ color: miner.thermals > 85 ? '#dc3545' : miner.thermals > 75 ? '#ffc107' : '#28a745' }}
                      >
                        {miner.thermals}°C
                      </span>
                    </div>
                  </div>
                  
                  <div style={{ margin: '15px 0' }}>
                    <p style={{ fontSize: '14px', color: '#6c757d', margin: '0 0 5px 0' }}>Upgrades:</p>
                    <div style={{ 
                      display: 'flex', 
                      flexWrap: 'wrap', 
                      gap: '5px' 
                    }}>
                      {miner.upgrades.length === 0 ? (
                        <span style={{ fontSize: '14px', color: '#6c757d' }}>No upgrades installed</span>
                      ) : (
                        miner.upgrades.map(upgradeId => {
                          const upgradeInfo = upgradeTemplates.find(u => u.id === upgradeId);
                          return (
                            <span 
                              key={upgradeId}
                              style={{
                                fontSize: '12px',
                                backgroundColor: '#e9ecef',
                                padding: '3px 8px',
                                borderRadius: '12px',
                              }}
                            >
                              {upgradeInfo?.name || upgradeId}
                            </span>
                          );
                        })
                      )}
                    </div>
                  </div>
                  
                  <div>
                    <button 
                      className={`${classes.button} ${classes.upgradeButton}`}
                      onClick={() => {
                        // Show available upgrades
                        const availableUpgrades = upgradeTemplates.filter(
                          upgrade => !miner.upgrades.includes(upgrade.id)
                        );
                        
                        if (availableUpgrades.length === 0) {
                          showNotification("No more upgrades available for this hardware!");
                          return;
                        }
                        
                        // For simplicity, just pick the first available upgrade
                        // In a real app, you'd show a modal with choices
                        addUpgrade(miner.id, availableUpgrades[0]);
                      }}
                    >
                      <FaTools /> Upgrade
                    </button>
                  </div>
                </div>
              ))
            )}
          </div>
        </>
      )}
      
      {selectedTab === 'shop' && (
        <div className={classes.shopSection}>
          <h3>Hardware Shop</h3>
          <p>Your balance: {bitcoin.toFixed(8)} BTC (${(bitcoin * bitcoinPrice).toFixed(2)})</p>
          
          <div className={classes.shopGrid}>
            {hardwareTemplates.map(hardware => (
              <div key={hardware.id} className={classes.shopItem}>
                <div className={classes.shopItemHeader}>
                  <h4>{hardware.name}</h4>
                  <div className={classes.shopItemPrice}>
                    <FaBitcoin /> {hardware.price.toFixed(2)} BTC
                  </div>
                </div>
                
                <p className={classes.shopItemDesc}>{hardware.description}</p>
                
                <div className={classes.shopItemStats}>
                  <p>
                    <span className="label">Hashrate:</span>
                    <span className="value">{formatNumber(hardware.hashrate)} H/s</span>
                  </p>
                  <p>
                    <span className="label">Power:</span>
                    <span className="value">{hardware.power}W</span>
                  </p>
                  <p>
                    <span className="label">Efficiency:</span>
                    <span className="value">{(hardware.hashrate / hardware.power).toFixed(2)} H/W</span>
                  </p>
                  <p>
                    <span className="label">ROI:</span>
                    <span className="value">~{calculateROI(hardware.price)} days</span>
                  </p>
                </div>
                
                <button 
                  className={classes.button}
                  onClick={() => addMiner(hardware)}
                  disabled={bitcoin < hardware.price}
                >
                  {bitcoin < hardware.price ? 'Insufficient Funds' : 'Purchase Hardware'}
                </button>
              </div>
            ))}
          </div>
          
          <h3 style={{ marginTop: '30px' }}>Upgrades Shop</h3>
          <p>Install these upgrades on your existing hardware to improve performance</p>
          
          <div className={classes.shopGrid}>
            {upgradeTemplates.map(upgrade => (
              <div key={upgrade.id} className={classes.shopItem}>
                <div className={classes.shopItemHeader}>
                  <h4>{upgrade.name}</h4>
                  <div className={classes.shopItemPrice}>
                    <FaBitcoin /> {upgrade.price.toFixed(2)} BTC
                  </div>
                </div>
                
                <p className={classes.shopItemDesc}>{upgrade.description}</p>
                
                <div className={classes.shopItemStats}>
                  {upgrade.effects.hashrate && (
                    <p>
                      <span className="label">Hashrate:</span>
                      <span className="value" style={{ color: '#28a745' }}>+{upgrade.effects.hashrate} H/s</span>
                    </p>
                  )}
                  {upgrade.effects.power && (
                    <p>
                      <span className="label">Power:</span>
                      <span className="value" style={{ color: upgrade.effects.power < 0 ? '#28a745' : '#dc3545' }}>
                        {upgrade.effects.power > 0 ? '+' : ''}{upgrade.effects.power}W
                      </span>
                    </p>
                  )}
                  {upgrade.effects.thermals && (
                    <p>
                      <span className="label">Temperature:</span>
                      <span className="value" style={{ color: upgrade.effects.thermals < 0 ? '#28a745' : '#dc3545' }}>
                        {upgrade.effects.thermals > 0 ? '+' : ''}{upgrade.effects.thermals}°C
                      </span>
                    </p>
                  )}
                </div>
                
                <button 
                  className={`${classes.button} ${classes.upgradeButton}`}
                  onClick={() => {
                    if (miners.length === 0) {
                      showNotification("You need mining hardware first!");
                      return;
                    }
                    
                    // For simplicity, upgrade the first miner
                    // In a real app, you'd show a modal to choose which miner to upgrade
                    addUpgrade(miners[0].id, upgrade);
                  }}
                  disabled={bitcoin < upgrade.price || miners.length === 0}
                >
                  {bitcoin < upgrade.price ? 'Insufficient Funds' : miners.length === 0 ? 'No Hardware' : 'Purchase Upgrade'}
                </button>
              </div>
            ))}
          </div>
        </div>
      )}
      
      {notification && (
        <div className={classes.notification}>
          {notification}
        </div>
      )}
    </div>
  );
};

export default BitcoinMiningSimulator;